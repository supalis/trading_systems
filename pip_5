package com.dukascopy.visualforex.supalis;

import java.util.*;
import com.dukascopy.api.*;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.concurrent.CopyOnWriteArrayList;
import java.lang.reflect.*;
import java.math.BigDecimal;


/*
 * Created by VisualJForex Generator, version 2.97
 * Date: 04.10.2020 14:54
 */
public class pip_5 implements IStrategy {

    private CopyOnWriteArrayList<TradeEventAction> tradeEventActions = new CopyOnWriteArrayList<TradeEventAction>();
    private static final String DATE_FORMAT_NOW = "yyyyMMdd_HHmmss";
    private IEngine engine;
    private IConsole console;
    private IHistory history;
    private IContext context;
    private IIndicators indicators;
    private IUserInterface userInterface;

    @Configurable("defaultTakeProfit:")
    public int defaultTakeProfit = 100;
    @Configurable("defaultInstrument:")
    public Instrument defaultInstrument = Instrument.EURUSD;
    @Configurable("_TE_Deviation:")
    public double _TE_Deviation = 0.1;
    @Configurable("defaultTradeAmount:")
    public double defaultTradeAmount = 0.01;
    @Configurable("defaultStopLoss:")
    public int defaultStopLoss = 100;
    @Configurable("_TE_Period:")
    public int _TE_Period = 14;
    @Configurable("_mode:")
    public int _mode = 0;
    @Configurable("defaultPeriod:")
    public Period defaultPeriod = Period.FIFTEEN_MINS;

    private Candle LastBidCandle =  null ;
    private String AccountId = "";
    private double _negative96;
    private double _negative95;
    private double _positive95;
    private double _positive96;
    private double Equity;
    private double _lowBand187;
    private Tick LastTick =  null ;
    private String AccountCurrency = "";
    private double _highBand187;
    private int OverWeekendEndLeverage;
    private double _AC_last2;
    private int _conv_last = 0;
    private double _AC_last;
    private double _AC_current;
    private double Leverage;
    private int defaultSlippage = 5;
    private int _conv_current = 0;
    private int _conv_buffer;
    private List<IOrder> PendingPositions =  null ;
    private boolean _trend_change = false;
    private double _TE_last;
    private double _last_pos_te;
    private double _highBand12;
    private IOrder _my_position =  null ;
    private double _positive116;
    private double _highBand36;
    private List<IOrder> OpenPositions =  null ;
    private double UseofLeverage;
    private double _TE_current;
    private IMessage LastTradeEvent =  null ;
    private double _negative116;
    private boolean GlobalAccount;
    private Candle LastAskCandle =  null ;
    private int MarginCutLevel;
    private List<IOrder> AllPositions =  null ;
    private double _lowBand12;
    private int _AC_impulse = 0;
    private double _lowBand36;


    public void onStart(IContext context) throws JFException {
        this.engine = context.getEngine();
        this.console = context.getConsole();
        this.history = context.getHistory();
        this.context = context;
        this.indicators = context.getIndicators();
        this.userInterface = context.getUserInterface();

        subscriptionInstrumentCheck(defaultInstrument);

        ITick lastITick = context.getHistory().getLastTick(defaultInstrument);
        LastTick = new Tick(lastITick, defaultInstrument);

        IBar bidBar = context.getHistory().getBar(defaultInstrument, defaultPeriod, OfferSide.BID, 1);
        IBar askBar = context.getHistory().getBar(defaultInstrument, defaultPeriod, OfferSide.ASK, 1);
        LastAskCandle = new Candle(askBar, defaultPeriod, defaultInstrument, OfferSide.ASK);
        LastBidCandle = new Candle(bidBar, defaultPeriod, defaultInstrument, OfferSide.BID);

        if (indicators.getIndicator("TrendEnvelopes") == null) {
            indicators.registerDownloadableIndicator("1282","TrendEnvelopes");
        }
        if (indicators.getIndicator("AC") == null) {
            indicators.registerDownloadableIndicator("1210","AC");
        }
        if (indicators.getIndicator("AC") == null) {
            indicators.registerDownloadableIndicator("1210","AC");
        }
        if (indicators.getIndicator("AC") == null) {
            indicators.registerDownloadableIndicator("1210","AC");
        }
        if (indicators.getIndicator("TrendEnvelopes") == null) {
            indicators.registerDownloadableIndicator("1282","TrendEnvelopes");
        }
        subscriptionInstrumentCheck(Instrument.fromString("EUR/USD"));

    }

    public void onAccount(IAccount account) throws JFException {
        AccountCurrency = account.getCurrency().toString();
        Leverage = account.getLeverage();
        AccountId= account.getAccountId();
        Equity = account.getEquity();
        UseofLeverage = account.getUseOfLeverage();
        OverWeekendEndLeverage = account.getOverWeekEndLeverage();
        MarginCutLevel = account.getMarginCutLevel();
        GlobalAccount = account.isGlobal();
    }

    private void updateVariables(Instrument instrument) {
        try {
            AllPositions = engine.getOrders();
            List<IOrder> listMarket = new ArrayList<IOrder>();
            for (IOrder order: AllPositions) {
                if (order.getState().equals(IOrder.State.FILLED)){
                    listMarket.add(order);
                }
            }
            List<IOrder> listPending = new ArrayList<IOrder>();
            for (IOrder order: AllPositions) {
                if (order.getState().equals(IOrder.State.OPENED)){
                    listPending.add(order);
                }
            }
            OpenPositions = listMarket;
            PendingPositions = listPending;
        } catch(JFException e) {
            e.printStackTrace();
        }
    }

    public void onMessage(IMessage message) throws JFException {
        if (message.getOrder() != null) {
            updateVariables(message.getOrder().getInstrument());
            LastTradeEvent = message;
            for (TradeEventAction event :  tradeEventActions) {
                IOrder order = message.getOrder();
                if (order != null && event != null && message.getType().equals(event.getMessageType())&& order.getLabel().equals(event.getPositionLabel())) {
                    Method method;
                    try {
                        method = this.getClass().getDeclaredMethod(event.getNextBlockId(), Integer.class);
                        method.invoke(this, new Integer[] {event.getFlowId()});
                    } catch (SecurityException e) {
                            e.printStackTrace();
                    } catch (NoSuchMethodException e) {
                          e.printStackTrace();
                    } catch (IllegalArgumentException e) {
                        e.printStackTrace();
                    } catch (IllegalAccessException e) {
                        e.printStackTrace();
                    } catch (InvocationTargetException e) {
                        e.printStackTrace();
                    } 
                    tradeEventActions.remove(event); 
                }
            }   
        }
    }

    public void onStop() throws JFException {
    }

    public void onTick(Instrument instrument, ITick tick) throws JFException {
        LastTick = new Tick(tick, instrument);
        updateVariables(instrument);


    }

    public void onBar(Instrument instrument, Period period, IBar askBar, IBar bidBar) throws JFException {
        LastAskCandle = new Candle(askBar, period, instrument, OfferSide.ASK);
        LastBidCandle = new Candle(bidBar, period, instrument, OfferSide.BID);
        updateVariables(instrument);
            If_block_10(1);

    }

    public void subscriptionInstrumentCheck(Instrument instrument) {
        try {
              Set<Instrument> instruments = new HashSet<Instrument>();
              instruments.add(instrument);
              context.setSubscribedInstruments(instruments, true);
          } catch (Exception e) {
              e.printStackTrace();
          }
        }

    public double round(double price, Instrument instrument) {
        BigDecimal big = new BigDecimal("" + price); 
        big = big.setScale(instrument.getPipScale() + 1, BigDecimal.ROUND_HALF_UP); 
        return big.doubleValue(); 
    }

    public ITick getLastTick(Instrument instrument) {
        try { 
            return (context.getHistory().getTick(instrument, 0)); 
        } catch (JFException e) { 
             e.printStackTrace();  
         } 
         return null; 
    }

    private  void If_block_10(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        Instrument argument_2 = LastBidCandle.getInstrument();
        if (argument_1 == null && argument_2 !=null || (argument_1!= null && !argument_1.equals(argument_2))) {
        }
        else if (argument_1!= null && argument_1.equals(argument_2)) {
            If_block_11(flow);
        }
    }

    private  void If_block_11(Integer flow) {
        Period argument_1 = defaultPeriod;
        Period argument_2 = LastBidCandle.getPeriod();
        if (argument_1 == null && argument_2 !=null || (argument_1!= null && !argument_1.equals(argument_2))) {
        }
        else if (argument_1!= null && argument_1.equals(argument_2)) {
            TrendEnvelopes_block_12(flow);
        }
    }

    private void TrendEnvelopes_block_12(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        Period argument_2 = defaultPeriod;
        int argument_3 = 0;
        int argument_4 = _TE_Period;
        double argument_5 = _TE_Deviation;
        OfferSide[] offerside = new OfferSide[1];
        IIndicators.AppliedPrice[] appliedPrice = new IIndicators.AppliedPrice[1];
        offerside[0] = OfferSide.BID;
        appliedPrice[0] = IIndicators.AppliedPrice.CLOSE;
        Object[] params = new Object[2];
        params[0] = _TE_Period;
        params[1] = _TE_Deviation;
        try {
            subscriptionInstrumentCheck(argument_1);
            long time = context.getHistory().getBar(argument_1, argument_2, OfferSide.BID, argument_3).getTime();
            Object[] indicatorResult = context.getIndicators().calculateIndicator(argument_1, argument_2, offerside,
                    "TrendEnvelopes", appliedPrice, params, Filter.WEEKENDS, 1, time, 0);
            if ((new Double(((double [])indicatorResult[0])[0])) == null) {
                this._lowBand12 = Double.NaN;
            } else { 
                this._lowBand12 = (((double [])indicatorResult[0])[0]);
            } 
            if ((new Double(((double [])indicatorResult[1])[0])) == null) {
                this._highBand12 = Double.NaN;
            } else { 
                this._highBand12 = (((double [])indicatorResult[1])[0]);
            } 
        MultipleAction_block_186(flow);
        } catch (JFException e) {
            e.printStackTrace();
            console.getErr().println(e);
            this._lowBand12 = Double.NaN;
            this._highBand12 = Double.NaN;
        }
    }

    private  void If_block_20(Integer flow) {
        double argument_1 = _highBand12;
        if (!Double.isNaN(argument_1)) {
            Assign_block_29(flow);
        }
        else if (Double.isNaN(argument_1)) {
        }
    }

    private  void Assign_block_28(Integer flow) {
        double argument_1 = _lowBand12;
        _TE_current =  argument_1;
            Assign_block_63(flow);
    }

    private  void Assign_block_29(Integer flow) {
        double argument_1 = _highBand12;
        _TE_current =  argument_1;
            Assign_block_62(flow);
    }

    private  void MultipleAction_block_33(Integer flow) {
        If_block_230(flow);
        If_block_145(flow);
        If_block_227(flow);
    }

    private  void MultipleAction_block_40(Integer flow) {
        TrendEnvelopes_block_187(flow);
    }

    private  void Assign_block_62(Integer flow) {
        int argument_1 = 1;
        _conv_current =  argument_1;
            MultipleAction_block_40(flow);
    }

    private  void Assign_block_63(Integer flow) {
        int argument_1 = -1;
        _conv_current =  argument_1;
            MultipleAction_block_40(flow);
    }

    private  void PositionsViewer_block_72(Integer flow) {
        List<IOrder> argument_1 = OpenPositions;
        for (IOrder order : argument_1){
            if (order.getState() == IOrder.State.OPENED||order.getState() == IOrder.State.FILLED){
                _my_position = order;
                MultipleAction_block_233(flow);
            }
        }
    }

    private void AC_block_95(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        Period argument_2 = defaultPeriod;
        int argument_3 = 0;
        int argument_4 = 5;
        int argument_5 = 34;
        OfferSide[] offerside = new OfferSide[1];
        IIndicators.AppliedPrice[] appliedPrice = new IIndicators.AppliedPrice[1];
        offerside[0] = OfferSide.BID;
        appliedPrice[0] = IIndicators.AppliedPrice.MEDIAN_PRICE;
        Object[] params = new Object[2];
        params[0] = 5;
        params[1] = 34;
        try {
            subscriptionInstrumentCheck(argument_1);
            long time = context.getHistory().getBar(argument_1, argument_2, OfferSide.BID, argument_3).getTime();
            Object[] indicatorResult = context.getIndicators().calculateIndicator(argument_1, argument_2, offerside,
                    "AC", appliedPrice, params, Filter.WEEKENDS, 1, time, 0);
            if ((new Double(((double [])indicatorResult[0])[0])) == null) {
                this._positive95 = Double.NaN;
            } else { 
                this._positive95 = (((double [])indicatorResult[0])[0]);
            } 
            if ((new Double(((double [])indicatorResult[1])[0])) == null) {
                this._negative95 = Double.NaN;
            } else { 
                this._negative95 = (((double [])indicatorResult[1])[0]);
            } 
        Calculation_block_108(flow);
        } catch (JFException e) {
            e.printStackTrace();
            console.getErr().println(e);
            this._positive95 = Double.NaN;
            this._negative95 = Double.NaN;
        }
    }

    private void AC_block_96(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        Period argument_2 = defaultPeriod;
        int argument_3 = 1;
        int argument_4 = 5;
        int argument_5 = 34;
        OfferSide[] offerside = new OfferSide[1];
        IIndicators.AppliedPrice[] appliedPrice = new IIndicators.AppliedPrice[1];
        offerside[0] = OfferSide.BID;
        appliedPrice[0] = IIndicators.AppliedPrice.MEDIAN_PRICE;
        Object[] params = new Object[2];
        params[0] = 5;
        params[1] = 34;
        try {
            subscriptionInstrumentCheck(argument_1);
            long time = context.getHistory().getBar(argument_1, argument_2, OfferSide.BID, argument_3).getTime();
            Object[] indicatorResult = context.getIndicators().calculateIndicator(argument_1, argument_2, offerside,
                    "AC", appliedPrice, params, Filter.WEEKENDS, 1, time, 0);
            if ((new Double(((double [])indicatorResult[0])[0])) == null) {
                this._positive96 = Double.NaN;
            } else { 
                this._positive96 = (((double [])indicatorResult[0])[0]);
            } 
            if ((new Double(((double [])indicatorResult[1])[0])) == null) {
                this._negative96 = Double.NaN;
            } else { 
                this._negative96 = (((double [])indicatorResult[1])[0]);
            } 
        Calculation_block_109(flow);
        } catch (JFException e) {
            e.printStackTrace();
            console.getErr().println(e);
            this._positive96 = Double.NaN;
            this._negative96 = Double.NaN;
        }
    }

    private  void OpenatMarket_block_103(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        double argument_2 = defaultTradeAmount;
        int argument_3 = defaultSlippage;
        int argument_4 = defaultStopLoss;
        int argument_5 = defaultTakeProfit;
        String argument_6 = "pip_trend_correction";
        ITick tick = getLastTick(argument_1);

        IEngine.OrderCommand command = IEngine.OrderCommand.BUY;

        double stopLoss = tick.getBid() - argument_1.getPipValue() * argument_4;
        double takeProfit = round(tick.getBid() + argument_1.getPipValue() * argument_5, argument_1);
        
           try {
               String label = getLabel();           
               IOrder order = context.getEngine().submitOrder(label, argument_1, command, argument_2, 0, argument_3,  stopLoss, takeProfit, 0, argument_6);
                Assign_block_218(flow);
        } catch (JFException e) {
            e.printStackTrace();
        }
    }

    private  void OpenatMarket_block_105(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        double argument_2 = defaultTradeAmount;
        int argument_3 = defaultSlippage;
        int argument_4 = defaultStopLoss;
        int argument_5 = defaultTakeProfit;
        String argument_6 = "pip_trend_correction";
        ITick tick = getLastTick(argument_1);

        IEngine.OrderCommand command = IEngine.OrderCommand.SELL;

        double stopLoss = tick.getAsk() + argument_1.getPipValue() * argument_4;
        double takeProfit = round(tick.getAsk() - argument_1.getPipValue() * argument_5, argument_1);
        
           try {
               String label = getLabel();           
               IOrder order = context.getEngine().submitOrder(label, argument_1, command, argument_2, 0, argument_3,  stopLoss, takeProfit, 0, argument_6);
                Assign_block_218(flow);
        } catch (JFException e) {
            e.printStackTrace();
        }
    }

    private void Calculation_block_108(Integer flow) {
        double argument_1 = _positive95;
        double argument_2 = _negative95;
        _AC_current = argument_1 + argument_2;
        AC_block_96(flow);
    }

    private void Calculation_block_109(Integer flow) {
        double argument_1 = _positive96;
        double argument_2 = _negative96;
        _AC_last = argument_1 + argument_2;
        AC_block_116(flow);
    }

    private  void If_block_110(Integer flow) {
        int argument_1 = _conv_current;
        int argument_2 = 0;
        if (argument_1< argument_2) {
            If_block_202(flow);
        }
        else if (argument_1> argument_2) {
            If_block_203(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_111(Integer flow) {
        double argument_1 = _AC_current;
        double argument_2 = 0.0;
        if (argument_1< argument_2) {
            If_block_206(flow);
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_113(Integer flow) {
        double argument_1 = _AC_current;
        double argument_2 = _AC_last;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
            If_block_118(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_114(Integer flow) {
        double argument_1 = _AC_current;
        double argument_2 = _AC_last;
        if (argument_1< argument_2) {
            If_block_115(flow);
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_115(Integer flow) {
        double argument_1 = _AC_last;
        double argument_2 = _AC_last2;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
            Assign_block_196(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private void AC_block_116(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        Period argument_2 = defaultPeriod;
        int argument_3 = 2;
        int argument_4 = 5;
        int argument_5 = 34;
        OfferSide[] offerside = new OfferSide[1];
        IIndicators.AppliedPrice[] appliedPrice = new IIndicators.AppliedPrice[1];
        offerside[0] = OfferSide.BID;
        appliedPrice[0] = IIndicators.AppliedPrice.MEDIAN_PRICE;
        Object[] params = new Object[2];
        params[0] = 5;
        params[1] = 34;
        try {
            subscriptionInstrumentCheck(argument_1);
            long time = context.getHistory().getBar(argument_1, argument_2, OfferSide.BID, argument_3).getTime();
            Object[] indicatorResult = context.getIndicators().calculateIndicator(argument_1, argument_2, offerside,
                    "AC", appliedPrice, params, Filter.WEEKENDS, 1, time, 0);
            if ((new Double(((double [])indicatorResult[0])[0])) == null) {
                this._positive116 = Double.NaN;
            } else { 
                this._positive116 = (((double [])indicatorResult[0])[0]);
            } 
            if ((new Double(((double [])indicatorResult[1])[0])) == null) {
                this._negative116 = Double.NaN;
            } else { 
                this._negative116 = (((double [])indicatorResult[1])[0]);
            } 
        Calculation_block_117(flow);
        } catch (JFException e) {
            e.printStackTrace();
            console.getErr().println(e);
            this._positive116 = Double.NaN;
            this._negative116 = Double.NaN;
        }
    }

    private void Calculation_block_117(Integer flow) {
        double argument_1 = _positive116;
        double argument_2 = _negative116;
        _AC_last2 = argument_1 + argument_2;
        Assign_block_200(flow);
    }

    private  void If_block_118(Integer flow) {
        double argument_1 = _AC_last;
        double argument_2 = _AC_last2;
        if (argument_1< argument_2) {
            Assign_block_199(flow);
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void OpenatMarket_block_172(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        double argument_2 = defaultTradeAmount;
        int argument_3 = defaultSlippage;
        int argument_4 = defaultStopLoss;
        int argument_5 = defaultTakeProfit;
        String argument_6 = "pip_new_trend";
        ITick tick = getLastTick(argument_1);

        IEngine.OrderCommand command = IEngine.OrderCommand.SELL;

        double stopLoss = tick.getAsk() + argument_1.getPipValue() * argument_4;
        double takeProfit = round(tick.getAsk() - argument_1.getPipValue() * argument_5, argument_1);
        
           try {
               String label = getLabel();           
               IOrder order = context.getEngine().submitOrder(label, argument_1, command, argument_2, 0, argument_3,  stopLoss, takeProfit, 0, argument_6);
                } catch (JFException e) {
            e.printStackTrace();
        }
    }

    private  void OpenatMarket_block_173(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        double argument_2 = defaultTradeAmount;
        int argument_3 = defaultSlippage;
        int argument_4 = defaultStopLoss;
        int argument_5 = defaultTakeProfit;
        String argument_6 = "pip_new_trend";
        ITick tick = getLastTick(argument_1);

        IEngine.OrderCommand command = IEngine.OrderCommand.BUY;

        double stopLoss = tick.getBid() - argument_1.getPipValue() * argument_4;
        double takeProfit = round(tick.getBid() + argument_1.getPipValue() * argument_5, argument_1);
        
           try {
               String label = getLabel();           
               IOrder order = context.getEngine().submitOrder(label, argument_1, command, argument_2, 0, argument_3,  stopLoss, takeProfit, 0, argument_6);
                } catch (JFException e) {
            e.printStackTrace();
        }
    }

    private  void If_block_179(Integer flow) {
        double argument_1 = _TE_current;
        double argument_2 = _TE_last;
        if (argument_1< argument_2) {
            SetStopLoss_block_180(flow);
        }
        else if (argument_1> argument_2) {
            SetStopLoss_block_180(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void SetStopLoss_block_180(Integer flow) {
        IOrder argument_1 = _my_position;
        double argument_2 = _TE_current;
        boolean isLong = argument_1.isLong();
        double stopLoss = round(argument_2, argument_1.getInstrument());
        try {
            argument_1.setStopLossPrice(stopLoss);
        } catch (JFException e) {
            e.printStackTrace();
        }
    }

    private  void If_block_185(Integer flow) {
        double argument_1 = _lowBand12;
        if (!Double.isNaN(argument_1)) {
            Assign_block_28(flow);
        }
        else if (Double.isNaN(argument_1)) {
        }
    }

    private  void MultipleAction_block_186(Integer flow) {
        If_block_185(flow);
        If_block_20(flow);
    }

    private void TrendEnvelopes_block_187(Integer flow) {
        Instrument argument_1 = defaultInstrument;
        Period argument_2 = defaultPeriod;
        int argument_3 = 1;
        int argument_4 = _TE_Period;
        double argument_5 = _TE_Deviation;
        OfferSide[] offerside = new OfferSide[1];
        IIndicators.AppliedPrice[] appliedPrice = new IIndicators.AppliedPrice[1];
        offerside[0] = OfferSide.BID;
        appliedPrice[0] = IIndicators.AppliedPrice.CLOSE;
        Object[] params = new Object[2];
        params[0] = _TE_Period;
        params[1] = _TE_Deviation;
        try {
            subscriptionInstrumentCheck(argument_1);
            long time = context.getHistory().getBar(argument_1, argument_2, OfferSide.BID, argument_3).getTime();
            Object[] indicatorResult = context.getIndicators().calculateIndicator(argument_1, argument_2, offerside,
                    "TrendEnvelopes", appliedPrice, params, Filter.WEEKENDS, 1, time, 0);
            if ((new Double(((double [])indicatorResult[0])[0])) == null) {
                this._lowBand187 = Double.NaN;
            } else { 
                this._lowBand187 = (((double [])indicatorResult[0])[0]);
            } 
            if ((new Double(((double [])indicatorResult[1])[0])) == null) {
                this._highBand187 = Double.NaN;
            } else { 
                this._highBand187 = (((double [])indicatorResult[1])[0]);
            } 
        MultipleAction_block_188(flow);
        } catch (JFException e) {
            e.printStackTrace();
            console.getErr().println(e);
            this._lowBand187 = Double.NaN;
            this._highBand187 = Double.NaN;
        }
    }

    private  void MultipleAction_block_188(Integer flow) {
        If_block_189(flow);
        If_block_190(flow);
    }

    private  void If_block_189(Integer flow) {
        double argument_1 = _lowBand187;
        if (!Double.isNaN(argument_1)) {
            Assign_block_191(flow);
        }
        else if (Double.isNaN(argument_1)) {
        }
    }

    private  void If_block_190(Integer flow) {
        double argument_1 = _highBand187;
        if (!Double.isNaN(argument_1)) {
            Assign_block_192(flow);
        }
        else if (Double.isNaN(argument_1)) {
        }
    }

    private  void Assign_block_191(Integer flow) {
        double argument_1 = _lowBand187;
        _TE_last =  argument_1;
            Assign_block_193(flow);
    }

    private  void Assign_block_192(Integer flow) {
        double argument_1 = _highBand187;
        _TE_last =  argument_1;
            Assign_block_194(flow);
    }

    private  void Assign_block_193(Integer flow) {
        int argument_1 = -1;
        _conv_last =  argument_1;
            MultipleAction_block_195(flow);
    }

    private  void Assign_block_194(Integer flow) {
        int argument_1 = 1;
        _conv_last =  argument_1;
            MultipleAction_block_195(flow);
    }

    private  void MultipleAction_block_195(Integer flow) {
        If_block_226(flow);
        If_block_229(flow);
        MultipleAction_block_33(flow);
    }

    private  void Assign_block_196(Integer flow) {
        int argument_1 = -1;
        _AC_impulse =  argument_1;
        }

    private  void If_block_197(Integer flow) {
        double argument_1 = _AC_current;
        double argument_2 = 0.0;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
            If_block_204(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void Assign_block_199(Integer flow) {
        int argument_1 = 1;
        _AC_impulse =  argument_1;
        }

    private  void Assign_block_200(Integer flow) {
        int argument_1 = 0;
        _AC_impulse =  argument_1;
            MultipleAction_block_208(flow);
    }

    private  void If_block_202(Integer flow) {
        int argument_1 = _AC_impulse;
        int argument_2 = 1;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
            If_block_210(flow);
        }
    }

    private  void If_block_203(Integer flow) {
        int argument_1 = _AC_impulse;
        int argument_2 = -1;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
            If_block_211(flow);
        }
    }

    private  void If_block_204(Integer flow) {
        double argument_1 = _AC_last;
        double argument_2 = 0.0;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
            If_block_205(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_205(Integer flow) {
        double argument_1 = _AC_last2;
        double argument_2 = 0.0;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
            If_block_114(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_206(Integer flow) {
        double argument_1 = _AC_last;
        double argument_2 = 0.0;
        if (argument_1< argument_2) {
            If_block_207(flow);
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_207(Integer flow) {
        double argument_1 = _AC_last2;
        double argument_2 = 0.0;
        if (argument_1< argument_2) {
            If_block_113(flow);
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void MultipleAction_block_208(Integer flow) {
        If_block_197(flow);
        If_block_111(flow);
        If_block_110(flow);
        If_block_228(flow);
        Assign_block_217(flow);
    }

    private  void If_block_210(Integer flow) {
        double argument_1 = _TE_current;
        double argument_2 = _last_pos_te;
        if (argument_1< argument_2) {
            OpenatMarket_block_103(flow);
        }
        else if (argument_1> argument_2) {
            OpenatMarket_block_103(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_211(Integer flow) {
        double argument_1 = _TE_current;
        double argument_2 = _last_pos_te;
        if (argument_1< argument_2) {
            OpenatMarket_block_105(flow);
        }
        else if (argument_1> argument_2) {
            OpenatMarket_block_105(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_145(Integer flow) {
        boolean argument_1 = _trend_change;
        boolean argument_2 = true;
        if (argument_1!= argument_2) {
        }
        else if (argument_1 == argument_2) {
            MultipleAction_block_239(flow);
        }
    }

    private  void Assign_block_212(Integer flow) {
        int argument_1 = _conv_current;
        _conv_buffer =  argument_1;
            If_block_215(flow);
    }

    private  void If_block_213(Integer flow) {
        int argument_1 = _conv_last;
        int argument_2 = _conv_buffer;
        if (argument_1< argument_2) {
            Assign_block_214(flow);
        }
        else if (argument_1> argument_2) {
            Assign_block_214(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void Assign_block_214(Integer flow) {
        boolean argument_1 = true;
        _trend_change =  argument_1;
        }

    private  void If_block_215(Integer flow) {
        int argument_1 = _conv_current;
        int argument_2 = 0;
        if (argument_1< argument_2) {
            OpenatMarket_block_173(flow);
        }
        else if (argument_1> argument_2) {
            OpenatMarket_block_172(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void Assign_block_216(Integer flow) {
        boolean argument_1 = false;
        _trend_change =  argument_1;
            Assign_block_212(flow);
    }

    private  void Assign_block_218(Integer flow) {
        double argument_1 = _TE_current;
        _last_pos_te =  argument_1;
        }

    private  void PositionsViewer_block_219(Integer flow) {
        List<IOrder> argument_1 = OpenPositions;
        for (IOrder order : argument_1){
            if (order.getState() == IOrder.State.OPENED||order.getState() == IOrder.State.FILLED){
                _my_position = order;
                If_block_220(flow);
            }
        }
    }

    private  void If_block_220(Integer flow) {
        boolean argument_1 = _my_position.isLong();
        boolean argument_2 = true;
        if (argument_1!= argument_2) {
            If_block_222(flow);
        }
        else if (argument_1 == argument_2) {
            If_block_223(flow);
        }
    }

    private  void If_block_222(Integer flow) {
        int argument_1 = _AC_impulse;
        int argument_2 = 1;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
            If_block_225(flow);
        }
    }

    private  void If_block_223(Integer flow) {
        int argument_1 = _AC_impulse;
        int argument_2 = -1;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
            If_block_225(flow);
        }
    }

    private  void CloseandCancelPosition_block_224(Integer flow) {
        try {
            if (_my_position != null && (_my_position.getState() == IOrder.State.OPENED||_my_position.getState() == IOrder.State.FILLED)){
                _my_position.close();
            }
        } catch (JFException e)  {
            e.printStackTrace();
        }
    }

    private  void Assign_block_217(Integer flow) {
        int argument_1 = _conv_current;
        _conv_buffer =  argument_1;
        }

    private  void If_block_225(Integer flow) {
        String argument_1 = _my_position.getComment();
        String argument_2 = "pip_trend_correction";
        if (argument_1 == null && argument_2 !=null || (argument_1!= null && !argument_1.equals(argument_2))) {
        }
        else if (argument_1!= null && argument_1.equals(argument_2)) {
            CloseandCancelPosition_block_224(flow);
        }
    }

    private  void If_block_226(Integer flow) {
        int argument_1 = _mode;
        int argument_2 = 2;
        if (argument_1< argument_2) {
            If_block_213(flow);
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
            If_block_213(flow);
        }
    }

    private  void If_block_227(Integer flow) {
        int argument_1 = _mode;
        int argument_2 = 2;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
            AC_block_95(flow);
        }
        else if (argument_1== argument_2) {
        }
    }

    private  void If_block_228(Integer flow) {
        int argument_1 = _mode;
        int argument_2 = 4;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
            PositionsViewer_block_219(flow);
        }
        else if (argument_1== argument_2) {
            PositionsViewer_block_219(flow);
        }
    }

    private  void If_block_229(Integer flow) {
        int argument_1 = _mode;
        int argument_2 = 5;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
            If_block_213(flow);
        }
    }

    private  void If_block_230(Integer flow) {
        int argument_1 = _mode;
        int argument_2 = 2;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
            PositionsViewer_block_72(flow);
        }
        else if (argument_1== argument_2) {
            PositionsViewer_block_72(flow);
        }
    }

    private  void If_block_231(Integer flow) {
        String argument_1 = _my_position.getComment();
        String argument_2 = "pip_trend_correction";
        if (argument_1 == null && argument_2 !=null || (argument_1!= null && !argument_1.equals(argument_2))) {
        }
        else if (argument_1!= null && argument_1.equals(argument_2)) {
            If_block_179(flow);
        }
    }

    private  void If_block_232(Integer flow) {
        String argument_1 = _my_position.getComment();
        String argument_2 = "pip_new_trend";
        if (argument_1 == null && argument_2 !=null || (argument_1!= null && !argument_1.equals(argument_2))) {
        }
        else if (argument_1!= null && argument_1.equals(argument_2)) {
            If_block_179(flow);
        }
    }

    private  void MultipleAction_block_233(Integer flow) {
        If_block_232(flow);
        If_block_231(flow);
    }

    private  void If_block_235(Integer flow) {
        int argument_1 = _mode;
        int argument_2 = 1;
        if (argument_1< argument_2) {
        }
        else if (argument_1> argument_2) {
        }
        else if (argument_1== argument_2) {
            PositionsViewer_block_237(flow);
        }
    }

    private  void CloseandCancelPosition_block_236(Integer flow) {
        try {
            if (_my_position != null && (_my_position.getState() == IOrder.State.OPENED||_my_position.getState() == IOrder.State.FILLED)){
                _my_position.close();
            }
        } catch (JFException e)  {
            e.printStackTrace();
        }
    }

    private  void PositionsViewer_block_237(Integer flow) {
        List<IOrder> argument_1 = OpenPositions;
        for (IOrder order : argument_1){
            if (order.getState() == IOrder.State.OPENED||order.getState() == IOrder.State.FILLED){
                _my_position = order;
                CloseandCancelPosition_block_236(flow);
            }
        }
    }

    private  void MultipleAction_block_239(Integer flow) {
        If_block_235(flow);
        Assign_block_216(flow);
    }

class Candle  {

    IBar bar;
    Period period;
    Instrument instrument;
    OfferSide offerSide;

    public Candle(IBar bar, Period period, Instrument instrument, OfferSide offerSide) {
        this.bar = bar;
        this.period = period;
        this.instrument = instrument;
        this.offerSide = offerSide;
    }

    public Period getPeriod() {
        return period;
    }

    public void setPeriod(Period period) {
        this.period = period;
    }

    public Instrument getInstrument() {
        return instrument;
    }

    public void setInstrument(Instrument instrument) {
        this.instrument = instrument;
    }

    public OfferSide getOfferSide() {
        return offerSide;
    }

    public void setOfferSide(OfferSide offerSide) {
        this.offerSide = offerSide;
    }

    public IBar getBar() {
        return bar;
    }

    public void setBar(IBar bar) {
        this.bar = bar;
    }

    public long getTime() {
        return bar.getTime();
    }

    public double getOpen() {
        return bar.getOpen();
    }

    public double getClose() {
        return bar.getClose();
    }

    public double getLow() {
        return bar.getLow();
    }

    public double getHigh() {
        return bar.getHigh();
    }

    public double getVolume() {
        return bar.getVolume();
    }
}
class Tick {

    private ITick tick;
    private Instrument instrument;

    public Tick(ITick tick, Instrument instrument){
        this.instrument = instrument;
        this.tick = tick;
    }

    public Instrument getInstrument(){
       return  instrument;
    }

    public double getAsk(){
       return  tick.getAsk();
    }

    public double getBid(){
       return  tick.getBid();
    }

    public double getAskVolume(){
       return  tick.getAskVolume();
    }

    public double getBidVolume(){
        return tick.getBidVolume();
    }

   public long getTime(){
       return  tick.getTime();
    }

   public ITick getTick(){
       return  tick;
    }
}

    protected String getLabel() {
        String label;
        label = "IVF" + getCurrentTime(LastTick.getTime()) + generateRandom(10000) + generateRandom(10000);
        return label;
    }

    private String getCurrentTime(long time) {
        SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT_NOW);
        return sdf.format(time);
    }

    private static String generateRandom(int n) {
        int randomNumber = (int) (Math.random() * n);
        String answer = "" + randomNumber;
        if (answer.length() > 3) {
            answer = answer.substring(0, 4);
        }
        return answer;
    }

    class TradeEventAction {
        private IMessage.Type messageType;
        private String nextBlockId = "";
        private String positionLabel = "";
        private int flowId = 0;

        public IMessage.Type getMessageType() {
            return messageType;
        }

        public void setMessageType(IMessage.Type messageType) {
            this.messageType = messageType;
        }

        public String getNextBlockId() {
            return nextBlockId;
        }

        public void setNextBlockId(String nextBlockId) {
            this.nextBlockId = nextBlockId;
        }
        public String getPositionLabel() {
            return positionLabel;
       }

        public void setPositionLabel(String positionLabel) {
            this.positionLabel = positionLabel;
        }
        public int getFlowId() {
            return flowId;
        }
        public void setFlowId(int flowId) {
            this.flowId = flowId;
        }
    }
}
